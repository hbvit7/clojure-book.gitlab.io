== Functions

[source, clojure]
----
;; function_say_hello.clj

(defn say-hello []
  (println "Hello world!"))

(say-hello)
----

=== Passing argument

[source, clojure]
----
;; function_with_arguments.clj

(defn say-hello [name]
  (println "Hello" name "!"))

(say-hello "Karthik")
----

== Function with multiple arguments

[source, clojure]
----
;; function-multiple-arguments.clj

(defn multiple-args
  ([arg-1] (println "One argument passed:" arg-1))
  ([arg-1 arg-2] (println "Two argument passed:" arg-1 arg-2)))

(multiple-args 1)
(multiple-args 1 2)
----


Output

----
One argument passed: 1
Two argument passed: 1 2
----

=== Accepting unlimited arguments

[source, clojure]
----
;; function_unlimited_arguments.clj

(defn unlimited-arguments [& args]
  (println "Arguments:" args)
  (println "Type of args:" (type args)))

(unlimited-arguments 1)
(println)
(unlimited-arguments 1 17 true "Karthik" :coder)
----

Output

----
Arguments: (1)
Type of args: clojure.lang.ArraySeq

Arguments: (1 17 true Karthik :coder)
Type of args: clojure.lang.ArraySeq
----


[source, clojure]
----
;; function_unlimited_arguments_2.clj

(defn unlimited-arguments [first-arg & args]
  (println "First argument:" first-arg)
  (println "Other arguments:" args))

(unlimited-arguments 1)
(println)
(unlimited-arguments 1 17 true "Karthik" :coder)
----

Output

----
First argument: 1
Other arguments: nil

First argument: 1
Other arguments: (17 true Karthik :coder)
----

[source, clojure]
----
;; function_unlimited_arguments_3.clj

(defn unlimited-arguments [first-arg second-arg & args]
  (println "First argument:" first-arg)
  (println "Second argument:" second-arg)
  (println "Other arguments:" args))

(unlimited-arguments 1 2)
(println)
(unlimited-arguments 1 17 true "Karthik" :coder)
----

Output

----
First argument: 1
Second argument: 2
Other arguments: nil

First argument: 1
Second argument: 17
Other arguments: (true Karthik :coder)
----

=== Returning stuff

[source, clojure]
----
;; function_returning_something.clj

(defn add [a b]
  (+ a b))

(println (add 2  3))
----


=== Recursion

[source, clojure]
----
;; function_recursion.clj

(defn count-down [number]
  (println number)
  (if (not (= 0 (dec number)))
    (count-down (dec number))))

(count-down 5)
----

[source, clojure]
----
;; function_recur.clj

(defn count-down [number]
  (println number)
  (if (not (= 0 (dec number)))
    (recur (dec number))))

(count-down 5)
----

[source, clojure]
----
;; function_sum_using_recursion.clj

(defn sum [numbers total]
  (if (empty? numbers)
    total
    (recur (rest numbers) (+ total (first numbers)))))

(println (sum [1 2 3 4 5], 0))
----

[source, clojure]
----
;; function_collection_sum.clj

(defn sum [numbers total]
  (if (empty? numbers)
    total
    (recur (rest numbers) (+ total (first numbers)))))

(defn collection-sum [collection]
  (sum collection 0))

(println (collection-sum [1 2 3 4 5]))
----

=== Multimethods

[source, clojure]
----
;; without_multimethods.clj

(defn print-welcome-message [person]
  (cond
    (string? person) (println "Welcome" person)
    (vector? person) (println  "Welcome" (first person) "from" (last person))
    (map? person)    (println "Welcome" (person "name") "from" (person "from"))))

(print-welcome-message "Karthik from Chennai")
(print-welcome-message ["Kalam" "Ramanthapuram"])
(print-welcome-message {"name" "Bharathiyaar" "from" "Yettaiyapuram"})
----

Output

----
Welcome Karthik from Chennai
Welcome Kalam from Ramanthapuram
Welcome Bharathiyaar from Yettaiyapuram
----

[source, clojure]
----
;; with_multimethods.clj

(defn welcome-person [person]
  (cond
    (string? person) :welcome-person-string
    (vector? person) :welcome-person-vector
    (map? person)    :welcome-person-map))

(defmulti print-welcome-message welcome-person)

(defmethod print-welcome-message :welcome-person-string [person]
  (println "Welcome" person))

(defmethod print-welcome-message :welcome-person-vector [person]
  (println  "Welcome" (first person) "from" (last person)))

(defmethod print-welcome-message :welcome-person-map [person]
  (println "Welcome" (person "name") "from" (person "from")))

(print-welcome-message "Karthik from Chennai")
(print-welcome-message ["Kalam" "Ramanthapuram"])
(print-welcome-message {"name" "Bharathiyaar" "from" "Yettaiyapuram"})
----

Output

----
Welcome Karthik from Chennai
Welcome Kalam from Ramanthapuram
Welcome Bharathiyaar from Yettaiyapuram
----

=== Pre and Post Condition Checking

[source, clojure]
----
;; function_pre.clj

(defn sum [a b]
  {:pre [(number? a) (number? b)]}
  (+ a b))

(println (sum 4 5))
;; (println (sum "4" 5)) ;; Thows an error
----

[source, clojure]
----
;; function_post.clj

(defn sum [a b]
  {:post [(number? %)]}
  "45")

(defn sum-without-post [a b]
  "45")

(println (sum-without-post 4 5))
(println (sum 4 5)) ;; ; Assert failed: (number? %)
----

[source, clojure]
----
;; function_pre_post.clj

(defn sum [a b]
  {:pre [(number? a) (number? b)]
   :post [(number? %)]}
  (+ a b))

(println (sum 4 5))
----


=== Docstring

[source, clojure]
----
;; docstring.clj

(defn sum 
  "Adds two numbers passed as arguments.
   
   The argumets should be numbers.

   **Usage**

   ```clojure
   (sum 4 5) ;; returns 9
   ```
  " 
  [a b]
  {:pre [(number? a) (number? b)]}
  (+ a b))

(println (sum 4 5))
----

----
clj꞉user꞉> (doc sum)
-------------------------
user/sum
([a b])
  Adds two numbers passed as arguments.
   
   The argumets should be numbers.

   **Usage**

   ```clojure
   (sum 4 5) ;; returns 9
   ```
  
nil
----

image::images/docstring.png[]

=== Anonymous Functions


[source, clojure]
----
;; anonymous_function.clj

(def print-something
  (fn [something]
    (println something))))

(print-something "something is better than nothing")
----

Output

----
something is better than nothing
----


=== Functions returning functions

[source, clojure]
----
;; function_returning_function.clj

(defn multiplier [multiply-with]
  (fn [number]
    (* number multiply-with)))

(def double-it
  (multiplier 2))

(def triple-it
  (multiplier 3))

(double-it 21)

(triple-it 14)
----


