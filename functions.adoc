== Functions

Abstraction is the key to greatness and progress. Michael Faraday discovered electricity and magnetism have a link, but I don't think about it when I drive my car. Everything is abstracted away behind the steering wheel and pedals. Abstraction is so important, that almost every programming language provides a way to abstract away complexity.

Functions are the way you can abstract away things in Clojure. Whenever a code gets complex, you can refactor it out as functions, and use those functions as building blocks. In fact, you have been using functions all along, say when you call `(+ 1 2)` in Clojure, the `+` is a function, and `1` and `2` are the value it receives. Technically we call the values received by the function as arguments. You really not worried or don't know what happens in computer when you execute `(+ 1 2)`, it's been neatly abstracted away behind the function `+`.

So let's see how to build our own functions in this chapter.


=== Saying Hello With Functions

So this is the code in Clojure to print Hello World:

[source, clojure]
----
(println "Hello world!")
----

Now, I want to short it, I want to make this same functionality available by calling just `(say-hello)`. To do that I first call a function called `defn` or define function

[source, clojure]
----
(defn )
----

To it, as a first argument I pass the function name `say-hello`:

[source, clojure]
----
(defn say-hello)
----

Now `say-hello`` is passed to `defn`, but since `say-hello` is defined as a function, we can accept arguments for it, but here we need no arguments as we are going to print Hello World!, so lets put empty square braces as no arguments will be accepted by `say-hello`

[source, clojure]
----
(defn say-hello [])
----

Now all we need to do is to write the function body, in the body we print hello world as shown below:

[source, clojure]
----
(defn say-hello []
  (println "Hello world!"))
----

So when ever we call `(say-hello)`, Hello World! gets printed. Below code shows the final version of say hello:

[source, clojure]
----
;; function_say_hello.clj

(defn say-hello []
  (println "Hello world!"))

(say-hello)
----

Output

----
Hello world!
nil
----

=== Passing Argument

[source, clojure]
----
;; function_with_arguments.clj

(defn say-hello [name]
  (println "Hello" name "!"))

(say-hello "Karthik")
----

[source, clojure]
----
;; function_circle_area.clj

(defn circle-area [radius]
  (* Math/PI (Math/pow radius 2)))

(circle-area 7)
----

Output

----
153.93804002589985
----

=== Function with multiple arguments

[source, clojure]
----
;; function-multiple-arguments.clj

(defn multiple-args
  ([arg-1] (println "One argument passed:" arg-1))
  ([arg-1 arg-2] (println "Two argument passed:" arg-1 arg-2)))

(multiple-args 1)
(multiple-args 1 2)
----


Output

----
One argument passed: 1
Two argument passed: 1 2
----

=== Accepting unlimited arguments

[source, clojure]
----
;; function_unlimited_arguments.clj

(defn unlimited-arguments [& args]
  (println "Arguments:" args)
  (println "Type of args:" (type args)))

(unlimited-arguments 1)
(println)
(unlimited-arguments 1 17 true "Karthik" :coder)
----

Output

----
Arguments: (1)
Type of args: clojure.lang.ArraySeq

Arguments: (1 17 true Karthik :coder)
Type of args: clojure.lang.ArraySeq
----


[source, clojure]
----
;; function_unlimited_arguments_2.clj

(defn unlimited-arguments [first-arg & args]
  (println "First argument:" first-arg)
  (println "Other arguments:" args))

(unlimited-arguments 1)
(println)
(unlimited-arguments 1 17 true "Karthik" :coder)
----

Output

----
First argument: 1
Other arguments: nil

First argument: 1
Other arguments: (17 true Karthik :coder)
----

[source, clojure]
----
;; function_unlimited_arguments_3.clj

(defn unlimited-arguments [first-arg second-arg & args]
  (println "First argument:" first-arg)
  (println "Second argument:" second-arg)
  (println "Other arguments:" args))

(unlimited-arguments 1 2)
(println)
(unlimited-arguments 1 17 true "Karthik" :coder)
----

Output

----
First argument: 1
Second argument: 2
Other arguments: nil

First argument: 1
Second argument: 17
Other arguments: (true Karthik :coder)
----

=== Returning stuff

[source, clojure]
----
;; function_returning_something.clj

(defn add [a b]
  (+ a b))

(println (add 2  3))
----


=== Recursion

[source, clojure]
----
;; function_recursion.clj

(defn count-down [number]
  (println number)
  (if (not (= 0 (dec number)))
    (count-down (dec number))))

(count-down 5)
----

[source, clojure]
----
;; function_recur.clj

(defn count-down [number]
  (println number)
  (if (not (= 0 (dec number)))
    (recur (dec number))))

(count-down 5)
----

[source, clojure]
----
;; function_sum_using_recursion.clj

(defn sum [numbers total]
  (if (empty? numbers)
    total
    (recur (rest numbers) (+ total (first numbers)))))

(println (sum [1 2 3 4 5], 0))
----

[source, clojure]
----
;; function_collection_sum.clj

(defn sum [numbers total]
  (if (empty? numbers)
    total
    (recur (rest numbers) (+ total (first numbers)))))

(defn collection-sum [collection]
  (sum collection 0))

(println (collection-sum [1 2 3 4 5]))
----

=== Multimethods

[source, clojure]
----
;; without_multimethods.clj

(defn print-welcome-message [person]
  (cond
    (string? person) (println "Welcome" person)
    (vector? person) (println  "Welcome" (first person) "from" (last person))
    (map? person)    (println "Welcome" (person "name") "from" (person "from"))))

(print-welcome-message "Karthik from Chennai")
(print-welcome-message ["Kalam" "Ramanthapuram"])
(print-welcome-message {"name" "Bharathiyaar" "from" "Yettaiyapuram"})
----

Output

----
Welcome Karthik from Chennai
Welcome Kalam from Ramanthapuram
Welcome Bharathiyaar from Yettaiyapuram
----

[source, clojure]
----
;; with_multimethods.clj

(defn welcome-person [person]
  (cond
    (string? person) :welcome-person-string
    (vector? person) :welcome-person-vector
    (map? person)    :welcome-person-map))

(defmulti print-welcome-message welcome-person)

(defmethod print-welcome-message :welcome-person-string [person]
  (println "Welcome" person))

(defmethod print-welcome-message :welcome-person-vector [person]
  (println  "Welcome" (first person) "from" (last person)))

(defmethod print-welcome-message :welcome-person-map [person]
  (println "Welcome" (person "name") "from" (person "from")))

(print-welcome-message "Karthik from Chennai")
(print-welcome-message ["Kalam" "Ramanthapuram"])
(print-welcome-message {"name" "Bharathiyaar" "from" "Yettaiyapuram"})
----

Output

----
Welcome Karthik from Chennai
Welcome Kalam from Ramanthapuram
Welcome Bharathiyaar from Yettaiyapuram
----

=== Pre and Post Condition Checking

[source, clojure]
----
;; function_pre.clj

(defn sum [a b]
  {:pre [(number? a) (number? b)]}
  (+ a b))

(println (sum 4 5))
;; (println (sum "4" 5)) ;; Thows an error
----

[source, clojure]
----
;; function_post.clj

(defn sum [a b]
  {:post [(number? %)]}
  "45")

(defn sum-without-post [a b]
  "45")

(println (sum-without-post 4 5))
(println (sum 4 5)) ;; ; Assert failed: (number? %)
----

[source, clojure]
----
;; function_pre_post.clj

(defn sum [a b]
  {:pre [(number? a) (number? b)]
   :post [(number? %)]}
  (+ a b))

(println (sum 4 5))
----


=== Docstring

[source, clojure]
----
;; docstring.clj

(defn sum 
  "Adds two numbers passed as arguments.
   
   The argumets should be numbers.

   **Usage**

   ```clojure
   (sum 4 5) ;; returns 9
   ```
  " 
  [a b]
  {:pre [(number? a) (number? b)]}
  (+ a b))

(println (sum 4 5))
----

----
clj꞉user꞉> (doc sum)
-------------------------
user/sum
([a b])
  Adds two numbers passed as arguments.
   
   The argumets should be numbers.

   **Usage**

   ```clojure
   (sum 4 5) ;; returns 9
   ```
  
nil
----

image::images/docstring.png[]

=== Anonymous Functions


[source, clojure]
----
;; anonymous_function.clj

(def print-something
  (fn [something]
    (println something))))

(print-something "something is better than nothing")
----

Output

----
something is better than nothing
----


=== Functions returning functions

[source, clojure]
----
;; function_returning_function.clj

(defn multiplier [multiply-with]
  (fn [number]
    (* number multiply-with)))

(def double-it
  (multiplier 2))

(def triple-it
  (multiplier 3))

(double-it 21)

(triple-it 14)
----


