=== Accepting unlimited arguments

It is possible to accept unlimited number of arguments in a Clojure function. For example `+` function can accept unlimited amount and can give us the sum:

[source, clojure]
----
(+ 1 2 3 5 7 -1)
----

Output

----
17
----

For our functions to accept unlimited number of arguments, prefix argument with a `& ` (and and space), take a look at the code below:

[source, clojure]
----
;; function_unlimited_arguments.clj

(defn unlimited-arguments [& args]
  (println "Arguments:" args)
  (println "Type of args:" (type args)))

(unlimited-arguments 1)
(println)
(unlimited-arguments 1 17 true "Karthik" :coder)
----

Output

----
Arguments: (1)
Type of args: clojure.lang.ArraySeq

Arguments: (1 17 true Karthik :coder)
Type of args: clojure.lang.ArraySeq
----

In the above example we have `& args`, between square brackets, so the function `unlimited-arguments` can accept any number of arguments.

Say if we call the function like this:

[source, clojure]
----
(unlimited-arguments 1)
----

Then we get the output as `Arguments: (1)` which is generated by this statement:

[source, clojure]
----
(println "Arguments:" args)
----

In the above code snippet we are just printing the arguments. In the below code snippet:

[source, clojure]
----
(println "Type of args:" (type args)
----

We are printing the type of `args` which seems to be `clojure.lang.ArraySeq`, which I think is some list. In similar fashion when we call:

[source, clojure]
----
(unlimited-arguments 1 17 true "Karthik" :coder)
----

All `1 17 true "Karthik" :coder`, seems to be bundled in `args` as a list, as you can see from the output its printed as `Arguments: (1 17 true Karthik :coder)`.

Let's say that we want a function where it accepts one or more arguments, we can code it like this:

[source, clojure]
----
;; function_unlimited_arguments_2.clj

(defn unlimited-arguments [first-arg & args]
  (println "First argument:" first-arg)
  (println "Other arguments:" args))

(unlimited-arguments 1)
(println)
(unlimited-arguments 1 17 true "Karthik" :coder)
----

Output

----
First argument: 1
Other arguments: nil

First argument: 1
Other arguments: (17 true Karthik :coder)
----

Look at `[first-arg & args]`, so the first argument gets captured in `first-arg`, the rest if they are there gets bundled up in `args` which is present after `&` inside the square braces.

In the example below, the function `unlimited-arguments` has to have minimum of two arguments:

[source, clojure]
----
;; function_unlimited_arguments_3.clj

(defn unlimited-arguments [first-arg second-arg & args]
  (println "First argument:" first-arg)
  (println "Second argument:" second-arg)
  (println "Other arguments:" args))

(unlimited-arguments 1 2)
(println)
(unlimited-arguments 1 17 true "Karthik" :coder)
----

Output

----
First argument: 1
Second argument: 2
Other arguments: nil

First argument: 1
Second argument: 17
Other arguments: (true Karthik :coder)
----

The first argument is caught by `first-arg` and the second by `second-arg`, the rest is bundled up as list in `args`.
