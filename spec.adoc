== Spec

:file-name: spec.clj

include::use_code_note.adoc[]

Clojure code is nothing but functions manipulating data. Data can be of any type like String, Number, Map, Vector, Set and so on. When data of the right type and format is not given to a function, the function might not work properly. So Clojure has inbuilt libraries that help you to check the data type, these are called spec. May be one could you them in pre-condition checking to see if the received data is of the right type and format, and you can use it in post condition checking to see if the received data is of the right type and format.

So in order to use spec, let's require it:

[source, clojure]
----
(require '[clojure.spec.alpha :as s])
----

Now we have required `spec` as `s`, so  rather than calling functions like `spec/something`, we can call it as `s/something` from now on.

Let's now see how to check if something is a string:

[source, clojure]
----
(s/valid? string? "Hello")
----

Output

----
true
----

So, if you see the above code, we use a function called `s/valid?` and we pass a function called  `string?`, which gives true or false if the passed argument is string or not. Now as a second argument to `s/valid?` we give `"Hello"`. `s/valid?` applies the function `string?` to the argument `"Hello"`, it returns `true` and hence `s/valid?` returns `true`.

Let's say we want to see 42 is a string, we specify it as follows:

[source, clojure]
----
(s/valid? string? 42)
----

Output

----
false
----

Since `(string? 42)` returns `false`, `(s/valid? string? 42) ` also returns false, thus failing the validation.

Below is the code to check if the passed argument is a number:

[source, clojure]
----
(s/valid? number? 42)
----

Output

----
true
----

For that to `s/valid?` we pass the function `number?` as first argument, and `42` as second argument. since 42 is a number, `(number? 42)` returns `true` and `(s/valid? number? 42)` also returns `true`.

Similarly below we check if something is an integer:

[source, clojure]
----
(s/valid? integer? 123)
----

Output

----
true
----

We check if something is double in the code below:

[source, clojure]
----
(s/valid? double? 123.45)
----

Output

----
true
----

Think of double as a number having a decimal point. in the below code 123 does not have a decimal point, so the check that it's a double fails:

[source, clojure]
----
(s/valid? double? 123)
----

Output

----
false
----

We can also check for collections or sequences, we check if `[1 2 3]` is a vector, which is true:

[source, clojure]
----
(s/valid? vector? [1 2 3])
----

Output

----
true
----

We check if passed argument is a map:

[source, clojure]
----
(s/valid? map? { 1 "one" 2 "two"})
----

Output

----
true
----

Below we check for set:

[source, clojure]
----
(s/valid? set? #{:apple :orange})
----

Output

----
true
----

We check for keyword:

[source, clojure]
----
(s/valid? keyword? :ubuntu)
----

Output

----
true
----

Say we want to check if something is a valid percentage, say in a grading system, a student can have grades from 0% to 100%, and he cannot have something negative, or something greater than 100. For that let's write a function:

[source, clojure]
----
(def valid-%? (s/and number? #(>= % 0) #(<= % 100)))
----

Output

----
#'user/valid-%?
----

So a percentage mark should be a number, so we get a code like this:

[source, clojure]
----
(number?)
----

**and** it should be greater than zero, so for the and, we use spec's `and` function:

[source, clojure]
----
(s/and
  number?
  ;; something to check if it's greater than zero 
)
----

To check if it's greater than or equal to zero, lets write a anonymous function:

[source, clojure]
----
(s/and
  number?
  #(>= % 0)
)
----

Now it should be less than or equal to 100, so for the and, we write a function and add it to and block as shown:

[source, clojure]
----
(s/and
  number?
  #(>= % 0)
  #(<= % 100)
)
----

Now let's define the entire stuff to some variable, I would call this variable valid percent, and it will be written like `valid-%?`, so tha final code will look like this:

[source, clojure]
----
(def valid-%?
  (s/and
    number?
    #(>= % 0)
    #(<= % 100)))
----

To show that you are professional Clojure programmer, you will put all in one line like this:

[source, clojure]
----
(def [source, clojure]
----
(def valid-%? (s/and number? #(>= % 0) #(<= % 100)))
----
 (s/and number? #(>= % 0) #(<= % 100)))
----

So we have got our `valid-%?`, now let's use it.

[source, clojure]
----
(s/valid? valid-%? 85)
----

Output

----
true
----

In the code above, 85 is a number, and it lies between 0 and 100, so it's a valid percentage and hence we get the output as `true`. In the example below, 105% makes no sense in grading, and hence it returns `false`. 

[source, clojure]
----
(s/valid? valid-%? 105)
----

Output

----
false
----

Similarly -15 is less than 0, so the below example returns false.

[source, clojure]
----
(s/valid? valid-%? -15)
----

Output

----
false
----

**Exercise**

Write a spec named `string-or-symbol?`, it must work like this:

[source, clojure]
----
(s/valid? string-or-symbol? "abc") ;; true
(s/valid? string-or-symbol? :abc) ;; true
(s/valid? string-or-symbol? 42) ;; false
----

For this exercise, one my take a look at https://clojuredocs.org/clojure.spec.alpha/or

=== Specing collection

[source, clojure]
----
(def string-collection? (s/coll-of string?))
----

Output

----
#'user/string-collection?
----

[source, clojure]
----
(s/valid? string-collection? ["Hi" "Hello"])
----

Output

----
true
----

[source, clojure]
----
(def number-or-string? (s/or :number number? :string string?))
----

Output

----
#'user/number-or-string?
----

[source, clojure]
----
(s/valid? number-or-string? 1)
----

Output

----
true
----

[source, clojure]
----
(s/valid? number-or-string? "Hi")
----

Output

----
true
----

[source, clojure]
----
(def number-or-string-collection? (s/coll-of number-or-string?))
----

Output

----
#'user/number-or-string-collection?
----

[source, clojure]
----
(s/valid? number-or-string-collection? [1 "Hi" "India" 42])
----

Output

----
true
----

[source, clojure]
----
(s/valid? number-or-string-collection? [1 "Hi" "India" 42 :symbol])
----

Output

----
false
----

=== Inspecting Collections

[source, clojure]
----
(def valid-person-vector? (s/cat :name string? :age number? :gender keyword?))
----

Output

----
user/valid-person-vector?
----

[source, clojure]
----
(s/valid? valid-person-vector? ["Karthik" 40 :male])
----

Output

----
true
----

[source, clojure]
----
(def valid-person-map?
  (s/keys :req-un [::name
                   ::age
                   ::gender]))
----

Output

----
#'user/valid-person-map?
----

[source, clojure]
----
(s/valid? valid-person-map? {:name "Karthik"
                             :age 40
                             :gender :male})
----

Output

----
true
----

=== Checking Maps

[source, clojure]
----
(s/def ::name string?)
----

Output

----
:user/name
----

[source, clojure]
----
(s/def ::age int?)
----

Output

----
:user/age
----

[source, clojure]
----
(s/def ::gender keyword?)
----

Output

----
:user/gender
----


[source, clojure]
----
(s/def ::person (s/keys :req-un [::name ::age ::gender]))
----

Output

----
:user/person
----


[source, clojure]
----
(s/valid? ::person {:name "Karthik"
                    :age 40
                    :gender :male})
----

Output

----
true
----


[source, clojure]
----
(s/valid? ::person {:name "Karthik"
                    :age "40"
                    :gender :male})
----

Output

----
false
----


=== Explaining Spec

[source, clojure]
----
(s/explain number? "42")
----

Output

----
"42" - failed: number?
----

[source, clojure]
----
(s/explain number? 42)
----

Output

----
Success!
----

[source, clojure]
----
(s/explain number-or-string? "56")
----

Output

----
Success!
----

[source, clojure]
----
(s/explain number-or-string? :56)
----

Output

----
:56 - failed: number? at: [:number]
:56 - failed: string? at: [:string]
nil
----

[source, clojure]
----
(s/conform number? 42)
----

Output

----
clojure.spec.alpha/invalid
----

[source, clojure]
----
(s/conform number? "42")
----

Output

----
clojure.spec.alpha/invalid
----

[source, clojure]
----
(s/conform number-or-string? :56)
----

Output

----
:clojure.spec.alpha/invalid
----

[source, clojure]
----
(s/explain number-or-string? 56)
----

Output

----
Success!
nil
----


=== Using Spec In Functions

[source, clojure]
----
(defn add-two-numbers [a b]
  {:pre [(s/valid? number? a)
         (s/valid? number? b)]}
  (+ a b))
----

[source, clojure]
----
(add-two-numbers 3 5)
----

Output

----
8
----

[source, clojure]
----
(add-two-numbers 3 "5")
----

Output

----
; Execution error (AssertionError) at user/add-two-numbers (REPL:100).
; Assert failed: (s/valid? number? b)
----
