== Spec

:file-name: spec.clj

include::use_code_note.adoc[]

Clojure code is nothing but functions manipulating data. Data can be of any type like String, Number, Map, Vector, Set and so on. When data of the right type and format is not given to a function, the function might not work properly. So Clojure has inbuilt libraries that help you to check the data type, these are called spec. May be one could you them in pre-condition checking to see if the received data is of the right type and format, and you can use it in post condition checking to see if the received data is of the right type and format.

So in order to use spec, let's require it:

[source, clojure]
----
(require '[clojure.spec.alpha :as s])
----

Now we have required `spec` as `s`, so  rather than calling functions like `spec/something`, we can call it as `s/something` from now on.

Let's now see how to check if something is a string:

[source, clojure]
----
(s/valid? string? "Hello")
----

Output

----
true
----

So, if you see the above code, we use a function called `s/valid?` and we pass a function called  `string?`, which gives true or false if the passed argument is string or not. Now as a second argument to `s/valid?` we give `"Hello"`. `s/valid?` applies the function `string?` to the argument `"Hello"`, it returns `true` and hence `s/valid?` returns `true`.

Let's say we want to see 42 is a string, we specify it as follows:

[source, clojure]
----
(s/valid? string? 42)
----

Output

----
false
----

Since `(string? 42)` returns `false`, `(s/valid? string? 42) ` also returns false, thus failing the validation.

Below is the code to check if the passed argument is a number:

[source, clojure]
----
(s/valid? number? 42)
----

Output

----
true
----

For that to `s/valid?` we pass the function `number?` as first argument, and `42` as second argument. since 42 is a number, `(number? 42)` returns `true` and `(s/valid? number? 42)` also returns `true`.

Similarly below we check if something is an integer:

[source, clojure]
----
(s/valid? integer? 123)
----

Output

----
true
----

We check if something is double in the code below:

[source, clojure]
----
(s/valid? double? 123.45)
----

Output

----
true
----

Think of double as a number having a decimal point. in the below code 123 does not have a decimal point, so the check that it's a double fails:

[source, clojure]
----
(s/valid? double? 123)
----

Output

----
false
----

We can also check for collections or sequences, we check if `[1 2 3]` is a vector, which is true:

[source, clojure]
----
(s/valid? vector? [1 2 3])
----

Output

----
true
----

We check if passed argument is a map:

[source, clojure]
----
(s/valid? map? { 1 "one" 2 "two"})
----

Output

----
true
----

Below we check for set:

[source, clojure]
----
(s/valid? set? #{:apple :orange})
----

Output

----
true
----

We check for keyword:

[source, clojure]
----
(s/valid? keyword? :ubuntu)
----

Output

----
true
----

Say we want to check if something is a valid percentage, say in a grading system, a student can have grades from 0% to 100%, and he cannot have something negative, or something greater than 100. For that let's write a function:

[source, clojure]
----
(def valid-%? (s/and number? #(>= % 0) #(<= % 100)))
----

Output

----
#'user/valid-%?
----

So a percentage mark should be a number, so we get a code like this:

[source, clojure]
----
(number?)
----

**and** it should be greater than zero, so for the and, we use spec's `and` function:

[source, clojure]
----
(s/and
  number?
  ;; something to check if it's greater than zero 
)
----

To check if it's greater than or equal to zero, lets write a anonymous function:

[source, clojure]
----
(s/and
  number?
  #(>= % 0)
)
----

Now it should be less than or equal to 100, so for the and, we write a function and add it to and block as shown:

[source, clojure]
----
(s/and
  number?
  #(>= % 0)
  #(<= % 100)
)
----

Now let's define the entire stuff to some variable, I would call this variable valid percent, and it will be written like `valid-%?`, so tha final code will look like this:

[source, clojure]
----
(def valid-%?
  (s/and
    number?
    #(>= % 0)
    #(<= % 100)))
----

To show that you are professional Clojure programmer, you will put all in one line like this:

[source, clojure]
----
(def [source, clojure]
----
(def valid-%? (s/and number? #(>= % 0) #(<= % 100)))
----
 (s/and number? #(>= % 0) #(<= % 100)))
----

So we have got our `valid-%?`, now let's use it.

[source, clojure]
----
(s/valid? valid-%? 85)
----

Output

----
true
----

In the code above, 85 is a number, and it lies between 0 and 100, so it's a valid percentage and hence we get the output as `true`. In the example below, 105% makes no sense in grading, and hence it returns `false`. 

[source, clojure]
----
(s/valid? valid-%? 105)
----

Output

----
false
----

Similarly -15 is less than 0, so the below example returns false.

[source, clojure]
----
(s/valid? valid-%? -15)
----

Output

----
false
----

**Exercise**

Write a spec named `string-or-symbol?`, it must work like this:

[source, clojure]
----
(s/valid? string-or-symbol? "abc") ;; true
(s/valid? string-or-symbol? :abc) ;; true
(s/valid? string-or-symbol? 42) ;; false
----

For this exercise, one my take a look at https://clojuredocs.org/clojure.spec.alpha/or

=== Specing collection

So let's see how to spec collections, in the example below, we define `string-collection?`

[source, clojure]
----
(def string-collection? (s/coll-of string?))
----

Output

----
#'user/string-collection?
----

So it's defined as follows `(s/coll-of string?)`, so the `coll-of` is a spec function, and its been told to check if all in a collection are of the the type `string?`. Now let's apply `string-collection?` on an array of strings:

[source, clojure]
----
(s/valid? string-collection? ["Hi" "Hello"])
----

Output

----
true
----

And it passes. Note that we pass `string-collection?` as an argument to `valid?`, and as a second argument we pass pass the array of strings `["Hi" "Hello"]`.

Now let's get bit more complicated and check if a array contains numbers and strings, look at the code below:

[source, clojure]
----
(def number-or-string? (s/or :number number? :string string?))
----

Output

----
#'user/number-or-string?
----

So in the above code we define `number-or-string?`, concentrate on this piece of code:

[source, clojure]
----
(s/or :number number? :string string?)
----

In t he above code we use `or` function in spec, and to it we pass four arguments, the first two being `:number number?`, and the second two being `:string string?`. Don't get confused by the pair of arguments now, you will understand why so soon. So the `or` receives `number?` and `string?` as arguments, prepended by keywords, so it passes when it either encounters a number or a string.

Let's put it into action, here I am testing it on a number and it passes:

[source, clojure]
----
(s/valid? number-or-string? 1)
----

Output

----
true
----

I test it on string and it passes too:

[source, clojure]
----
(s/valid? number-or-string? "Hi")
----

Output

----
true
----

Now if I want to check if a a collection only has number or string i write a code as shown:

[source, clojure]
----
(def number-or-string-collection? (s/coll-of number-or-string?))
----

Output

----
#'user/number-or-string-collection?
----

In the above code we pass `number-or-string?` to `coll-of` which turns it into a collection checker, its been defined to `number-or-string-collection?`, so from now on `number-or-string-collection?` will check if collection contains numbers and strings, if it contains any thing other than that, it will fail.

So the below collection / vector contains numbers and string and so it passes `number-or-string-collection?`:

[source, clojure]
----
(s/valid? number-or-string-collection? [1 "Hi" "India" 42])
----

Output

----
true
----

The below vector contains a keyword and so it fails:

[source, clojure]
----
(s/valid? number-or-string-collection? [1 "Hi" "India" 42 :keyword])
----

Output

----
false
----

=== Inspecting Collections

[source, clojure]
----
(def valid-person-vector? (s/cat :name string? :age number? :gender keyword?))
----

Output

----
user/valid-person-vector?
----

[source, clojure]
----
(s/valid? valid-person-vector? ["Karthik" 40 :male])
----

Output

----
true
----

[source, clojure]
----
(def valid-person-map?
  (s/keys :req-un [::name
                   ::age
                   ::gender]))
----

Output

----
#'user/valid-person-map?
----

[source, clojure]
----
(s/valid? valid-person-map? {:name "Karthik"
                             :age 40
                             :gender :male})
----

Output

----
true
----

=== Checking Maps

[source, clojure]
----
(s/def ::name string?)
----

Output

----
:user/name
----

[source, clojure]
----
(s/def ::age int?)
----

Output

----
:user/age
----

[source, clojure]
----
(s/def ::gender keyword?)
----

Output

----
:user/gender
----


[source, clojure]
----
(s/def ::person (s/keys :req-un [::name ::age ::gender]))
----

Output

----
:user/person
----


[source, clojure]
----
(s/valid? ::person {:name "Karthik"
                    :age 40
                    :gender :male})
----

Output

----
true
----


[source, clojure]
----
(s/valid? ::person {:name "Karthik"
                    :age "40"
                    :gender :male})
----

Output

----
false
----


=== Explaining Spec

[source, clojure]
----
(s/explain number? "42")
----

Output

----
"42" - failed: number?
----

[source, clojure]
----
(s/explain number? 42)
----

Output

----
Success!
----

[source, clojure]
----
(s/explain number-or-string? "56")
----

Output

----
Success!
----

[source, clojure]
----
(s/explain number-or-string? :56)
----

Output

----
:56 - failed: number? at: [:number]
:56 - failed: string? at: [:string]
nil
----

[source, clojure]
----
(s/conform number? 42)
----

Output

----
clojure.spec.alpha/invalid
----

[source, clojure]
----
(s/conform number? "42")
----

Output

----
clojure.spec.alpha/invalid
----

[source, clojure]
----
(s/conform number-or-string? :56)
----

Output

----
:clojure.spec.alpha/invalid
----

[source, clojure]
----
(s/explain number-or-string? 56)
----

Output

----
Success!
nil
----


=== Using Spec In Functions

[source, clojure]
----
(defn add-two-numbers [a b]
  {:pre [(s/valid? number? a)
         (s/valid? number? b)]}
  (+ a b))
----

[source, clojure]
----
(add-two-numbers 3 5)
----

Output

----
8
----

[source, clojure]
----
(add-two-numbers 3 "5")
----

Output

----
; Execution error (AssertionError) at user/add-two-numbers (REPL:100).
; Assert failed: (s/valid? number? b)
----
