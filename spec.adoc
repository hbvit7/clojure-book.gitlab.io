== Spec

:file-name: spec.clj

include::use_code_note.adoc[]

Clojure code is nothing but functions manipulating data. Data can be of any type like String, Number, Map, Vector, Set and so on. When data of the right type and format is not given to a function, the function might not work properly. So Clojure has inbuilt libraries that help you to check the data type, these are called spec. May be one could you them in pre-condition checking to see if the received data is of the right type and format, and you can use it in post condition checking to see if the received data is of the right type and format.

So in order to use spec, let's require it:

[source, clojure]
----
(require '[clojure.spec.alpha :as s])
----

Now we have required `spec` as `s`, so  rather than calling functions like `spec/something`, we can call it as `s/something` from now on.

Let's now see how to check if something is a string:

[source, clojure]
----
(s/valid? string? "Hello")
----

Output

----
true
----

[source, clojure]
----
(s/valid? string? 42)
----

Output

----
false
----

[source, clojure]
----
(s/valid? number? 42)
----

Output

----
true
----

[source, clojure]
----
(s/valid? integer? 123)
----

Output

----
true
----

[source, clojure]
----
(s/valid? double? 123.45)
----

Output

----
true
----

[source, clojure]
----
(s/valid? double? 123)
----

Output

----
false
----

[source, clojure]
----
(s/valid? vector? [1 2 3])
----

Output

----
true
----

[source, clojure]
----
(s/valid? map? { 1 "one" 2 "two"})
----

Output

----
true
----

[source, clojure]
----
(s/valid? set? #{:apple :orange})
----

Output

----
true
----

[source, clojure]
----
(s/valid? keyword? :ubuntu)
----

Output

----
true
----

[source, clojure]
----
(def valid-%? (s/and number? #(>= % 0) #(<= % 100)))
----

Output

----
#'user/valid-%?
----

[source, clojure]
----
(s/valid? valid-%? 85)
----

Output

----
true
----

[source, clojure]
----
(s/valid? valid-%? 105)
----

Output

----
false
----

[source, clojure]
----
(s/valid? valid-%? -15)
----

Output

----
false
----


=== Specing collection

[source, clojure]
----
(def string-collection? (s/coll-of string?))
----

Output

----
#'user/string-collection?
----

[source, clojure]
----
(s/valid? string-collection? ["Hi" "Hello"])
----

Output

----
true
----

[source, clojure]
----
(def number-or-string? (s/or :number number? :string string?))
----

Output

----
#'user/number-or-string?
----

[source, clojure]
----
(s/valid? number-or-string? 1)
----

Output

----
true
----

[source, clojure]
----
(s/valid? number-or-string? "Hi")
----

Output

----
true
----

[source, clojure]
----
(def number-or-string-collection? (s/coll-of number-or-string?))
----

Output

----
#'user/number-or-string-collection?
----

[source, clojure]
----
(s/valid? number-or-string-collection? [1 "Hi" "India" 42])
----

Output

----
true
----

[source, clojure]
----
(s/valid? number-or-string-collection? [1 "Hi" "India" 42 :symbol])
----

Output

----
false
----

=== Inspecting Collections

[source, clojure]
----
(def valid-person-vector? (s/cat :name string? :age number? :gender keyword?))
----

Output

----
user/valid-person-vector?
----

[source, clojure]
----
(s/valid? valid-person-vector? ["Karthik" 40 :male])
----

Output

----
true
----

[source, clojure]
----
(def valid-person-map?
  (s/keys :req-un [::name
                   ::age
                   ::gender]))
----

Output

----
#'user/valid-person-map?
----

[source, clojure]
----
(s/valid? valid-person-map? {:name "Karthik"
                             :age 40
                             :gender :male})
----

Output

----
true
----

=== Checking Maps

[source, clojure]
----
(s/def ::name string?)
----

Output

----
:user/name
----

[source, clojure]
----
(s/def ::age int?)
----

Output

----
:user/age
----

[source, clojure]
----
(s/def ::gender keyword?)
----

Output

----
:user/gender
----


[source, clojure]
----
(s/def ::person (s/keys :req-un [::name ::age ::gender]))
----

Output

----
:user/person
----


[source, clojure]
----
(s/valid? ::person {:name "Karthik"
                    :age 40
                    :gender :male})
----

Output

----
true
----


[source, clojure]
----
(s/valid? ::person {:name "Karthik"
                    :age "40"
                    :gender :male})
----

Output

----
false
----


=== Explaining Spec

[source, clojure]
----
(s/explain number? "42")
----

Output

----
"42" - failed: number?
----

[source, clojure]
----
(s/explain number? 42)
----

Output

----
Success!
----

[source, clojure]
----
(s/explain number-or-string? "56")
----

Output

----
Success!
----

[source, clojure]
----
(s/explain number-or-string? :56)
----

Output

----
:56 - failed: number? at: [:number]
:56 - failed: string? at: [:string]
nil
----

[source, clojure]
----
(s/conform number? 42)
----

Output

----
clojure.spec.alpha/invalid
----

[source, clojure]
----
(s/conform number? "42")
----

Output

----
clojure.spec.alpha/invalid
----

[source, clojure]
----
(s/conform number-or-string? :56)
----

Output

----
:clojure.spec.alpha/invalid
----

[source, clojure]
----
(s/explain number-or-string? 56)
----

Output

----
Success!
nil
----


=== Using Spec In Functions

[source, clojure]
----
(defn add-two-numbers [a b]
  {:pre [(s/valid? number? a)
         (s/valid? number? b)]}
  (+ a b))
----

[source, clojure]
----
(add-two-numbers 3 5)
----

Output

----
8
----

[source, clojure]
----
(add-two-numbers 3 "5")
----

Output

----
; Execution error (AssertionError) at user/add-two-numbers (REPL:100).
; Assert failed: (s/valid? number? b)
----
