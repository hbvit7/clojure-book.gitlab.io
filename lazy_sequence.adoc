== Lazy Sequence

Some sequences are evaluated only when they need to be evaluated, these are called lazy sequence. For example you can very easily create a lazy sequence of infinite numbers, or any other thing and your computer won't crash.

It's like this, when I say infinite, your brain doesn't crash, it just knows the concept of infinity and how it would fit into mathematics, when you need to use it in mathematics say in calculus, you still are able to apply and use it.

=== repeat

:file-name: lazy_sequence_repeat.clj

include::use_code_note.adoc[]

So let's take a look at `repeat` function. Take a look at the code below:

[source, clojure]
----
(def multiverse (repeat "universe"))
----

In the above code, we are creating a variable named `multiverse` which has many `"universe"` in it, theoretically it is infinite. So treating it as a sequence, let's take the first element from it:

[source, clojure]
----
(first multiverse)
----

Output

----
"universe"
----

And we get `"universe"`. Now let's take 5 elements from it:

[source, clojure]
----
(take 5 multiverse)
----

Output

----
("universe" "universe" "universe" "universe" "universe")
----

We get 5 universes. Let's take the `rest` from it:

[source, clojure]
----
;; (rest multiverse) ;; doesn't seem to work
----

And it throws an error, how can you get get rest of infinite universes any way?

Similarly `last` too throws error, how can you get the last element of infinite sequence?:

[source, clojure]
----
;; (last multiverse) ;; doesn't seem to work
----

Now let's get the 10,000^th^ multiverse:

[source, clojure]
----
(nth multiverse 10,000)
----

Output

----
"universe"
----

Let's get the 100^th^ multiverse:

[source, clojure]
----
(nth multiverse 100)
----

Output

----
"universe"
----

It's not that repeat creates just infinite sequence, we can create finite sequence by telling Clojure how many times to repeat. the code below only creates 5 `"universe"`:

[source, clojure]
----
(repeat 5 "universe")
----

Output

----
("universe" "universe" "universe" "universe" "universe")
----

If we try to access the 7^th^ element, it throws an exception:

[source, clojure]
----
(nth (repeat 5 "universe") 6)
----

Output

----
; Execution error (IndexOutOfBoundsException) at user/eval2056 (REPL:11).
; null
----

Whereas, since there are only 5 elements in `(repeat 5 `"unoverse")`, the code below only retrieves the 4^th^ element, so it works. 

[source, clojure]
----
(nth (repeat 5 "universe") 3)
----

Output

----
"universe"
----

Since `(repeat 5 "universe")` has finite elements `rest` works on it without raising any exceptions: 

[source, clojure]
----
(rest (repeat 5 "universe"))
----

Output

----
("universe" "universe" "universe" "universe"
----

similarly `last` too works on it: 

[source, clojure]
----
(last (repeat 5 "universe"))
----

Output

----
"universe"
----

=== cycle

:file-name: lazy_sequence_cycle.clj

include::use_code_note.adoc[]

[source, clojure]
----
(def multiverse (cycle ["universe" "antiverse"]))
----

[source, clojure]
----
(first multiverse)
----

[source, clojure]
----
(second multiverse)
----

[source, clojure]
----
(take 5 multiverse)
----

[source, clojure]
----
(nth multiverse 2000)
----

[source, clojure]
----
(nth multiverse 1783)
----

[source, clojure]
----
(def tiffin-items
  (cycle ["idli", "vadai", "dosai", "sambar"]))
----

[source, clojure]
----
(nth tiffin-items 5)
----

[source, clojure]
----
(take 10 tiffin-items)
----

=== iterate

:file-name: lazy_sequence_iterate.clj

include::use_code_note.adoc[]

[source, clojure]
----
(def all-numbers (iterate inc 1))
----

[source, clojure]
----
(nth all-numbers 24)
----

[source, clojure]
----
(take 10 all-numbers)
----




